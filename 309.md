# 动态规划
## 递归
dp 代表第 i 天结束的利润
0 代表未持有 1 代表持有
dp[i + 1][0] = max(dp[i][0], dp[i][1] + prices[i])
dp[i + 1][1] = max(dp[i][1], dp[i - 1][0] - prices[i - 1])
dp[0] = -inf // 虚拟头节点 -1 天利润为 0
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<array<int, 2>> dp(n, {-1, -1});

        auto dfs = [&](this auto&& dfs, int i, bool hold) -> int {
            if (i < 0) {
                if (hold) {
                    return INT_MIN;
                } else {
                    return 0;
                }
            }

            int& res = dp[i][hold];
            
            if (res != -1) {
                return res;
            }

            if (hold) {
                return res = max(dfs(i - 1, true), dfs(i - 2, false) - prices[i]);
            }
            // hold == false
            return res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]);
            
        };

        return dfs(n - 1, false);
    }
};
```
## 递推
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<array<int, 2>> dp(n + 2);
        dp[1][1] = INT_MIN; // 相当于是 -1 dp数组相对于prices 后移两位
        for (int i = 0; i < n; i++) {
            // prices[i] 是当天的股票价格
            dp[i + 2][0] = max(dp[i + 1][0], dp[i + 1][1] + prices[i]);
            // 因为我们肯定中间是没有空窗期的
            // 也就是说我们会一直持有股票 除非是在冷冻期
            // 那么如果 是 0 就说明下一天一定是冷冻期
            // 那么这里就要跨过两天的 dp
            dp[i + 2][1] = max(dp[i + 1][1], dp[i][0] - prices[i]);
        }
        return dp[n][0];
    }
};
```