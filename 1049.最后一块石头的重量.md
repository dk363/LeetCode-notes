# 动态规划
## 一维数组
要将石头分成两堆 使得这两堆之间的差最小
1. 确定dp数组下标的含义
dp 代表当前背包可以装的最大容量
石头的重量是 stones[i] value is stones[i] too
2. 确定递推公式
dp[i] = max(dp[i- c] + c, dp[i])
这里还是像 494 那样将二维数组转化为一维 
3. dp数组如何初始化
由上面的分析可知，将 dp 数组全部初始化为 0 且数组长度要是 target (sum / 2)
4. 确定遍历顺序
外层从前往后遍历物品 内层从后往前遍历背包容量
5. 举例推导dp数组
```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = reduce(stones.begin(), stones.end());
        int target = sum / 2;

        vector<int> dp(target + 1, 0);
        for (int x : stones) {
            for (int c = target; c >= x; c--) {
                dp[c] = max(dp[c - x] + x, dp[c]);
            }
        }

        return sum - 2 * dp[target];
    }
};
```