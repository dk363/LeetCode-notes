# 山形 + 贪心
将严格递增段和严格递减段分为一座山
这是贪心算法中简单而且容易理解的一种分法
计算严格递增段的长度
计算严格递减段的长度
计算峰顶的长度 注意这里，严格递减段的长度不一定比严格递增段的长度长，因此严格递减也可以从 0 开始，相当于是反向的严格递增段，然后峰顶的长度一定要另外计算
```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int ans = n;
        for (int i = 0; i < n; i++) {
            int start = i > 0 && ratings[i - 1] < ratings[i] ? i - 1 : i;

            while (i + 1 < n && ratings[i] < ratings[i + 1]) {
                i++;
            }
            int top = i;

            while (i + 1 < n && ratings[i] > ratings[i + 1]) {
                i++;
            }
            int inc = top - start;
            int dec = i - top;
            ans += ((inc - 1) * inc + (dec - 1) * dec) / 2 + max(inc, dec); // max 计算峰顶的长度
        }
        return ans;
    }
};
```

# 两次遍历
一次从左往右 一次从右往左
```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> candyNums(n, 1);
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candyNums[i] = candyNums[i - 1] + 1;
            }
        }

        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candyNums[i] = max(candyNums[i], candyNums[i + 1] + 1); // 注意这里前面已经修改过一次数组了
                // 要满足前面的的条件的同时 满足后面的条件
            }
        }
        
        int count = 0;
        for (int x : candyNums) {
            count += x;
        }
        
        return count;
    }
};
```