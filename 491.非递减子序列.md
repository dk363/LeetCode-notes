# 回溯 + 哈希
这里我们要找到递增的子序列，所以我们就不可以破坏原来的数组的顺序
所以这里用一个哈希集合来保存已经出现过的元素

```c++
class Solution {
    vector<int> path;
    vector<vector<int>> ans;

    void dfs(vector<int>& nums, int start) {
        if (path.size() > 1) {
            ans.push_back(path);
        }
        
        unordered_set<int> seen; 
        // 注意这里的seen只能管这一层，
        // 所以我们不必担心如果下一个元素是相同而不会将他加入 path 中
        // 如果我们在同一层看到相同的元素，大可以跳过，题目要求是不同的数组
        for (int i = start; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back()) ||
                seen.find(nums[i]) != seen.end()) { // != end 代表看到过
                    continue;    
                }
            seen.insert(nums[i]);
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        dfs(nums, 0);
        return ans;
    }
};
```

# 回溯 + 数组
因为题目说明 `nums[i]` 在 [-100, 100] 之间
所以这里我们完全可以用数组代替
> RECALL
> 哈希就是通过数组实现的
> 通过将元素通过哈希计算，使元素能够均匀分配在桶中
> 使得用更少的数组实现功能

```c++
class Solution {
    vector<int> path;
    vector<vector<int>> ans;

    void dfs(vector<int>& nums, int start) {
        if (path.size() > 1) {
            ans.push_back(path);
        }
        
        int seen[201] = {0}; 
        for (int i = start; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back()) ||
                seen[nums[i] + 100] == 1) {
                    continue;    
                }
            seen[nums[i] + 100] = 1;
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        dfs(nums, 0);
        return ans;
    }
};
```
