# dynamic programming
```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = t.size();
        // dp[i][c] 代表在 大于等于 i 这个下标的字符串中 c 的下一个索引
        // 26 表示小写字母的数量，n + 1 是为了处理边界情况（包括字符串末尾）
        vector<array<int, 26>> nxt(n + 1);
        // 为什么要用n来填充呢？
        // 我们规定如果 当前的下标等于 n 那么就相当于是没找到 但是如果 其实真的等于 n 呢？
        // 如果用 n 作为“未找到”的标记，当实际下标等于 n 时会产生歧义，容易出错。
        // 因此我们用 INT_MAX 作为“未找到”的标记，这样语义更清晰，也能避免越界风险。
        ranges::fill(nxt[n], n);
        for (int i = n - 1; i >= 0; i--) {
            nxt[i] = nxt[i + 1];
            nxt[i][t[i] - 'a'] = i;
        }

        // 这个写法无论 s 为空还是 t 为空，都能算出正确答案
        int i = -1; // i 记录的是上一个字符在 t 中的位置
        for (char c : s) {
            // 但是如果规定 INT_MAX
            // 这里会不会有越界的风险呢
            // 这里还是换回 n
            i = nxt[i + 1][c - 'a'];
            if (i == n) { // c 不在 t 中，说明 s 不是 t 的子序列
                return false;
            }
        }
        return true; // s 是 t 的子序列
    }
};
```