# 回溯 + 回文串判定
回溯还是画一棵树比较好理解
```c++
class Solution {
    vector<string> path;
    vector<vector<string>> ans;

    void dfs(string s, int start) {
        if (start >= s.size()) {
            ans.push_back(path);
            return;
        }

        for (int i = start; i < s.size(); i++) {
            if (isPalindrome(s, start, i)) {
                path.push_back(s.substr(start, i - start + 1));
            } else {
                continue;
            }
            dfs(s, i + 1);
            path.pop_back();
        }
    }

    bool isPalindrome(string s, int start, int end) {
        for (int i = start, j = end; i <= j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) {
        dfs(s, 0);
        return ans;
    }
};
```

## 回文串判定优化
这里我们怎么做优化呢？
可不可以像之前的题目一样做剪枝？
之前的剪枝是有额外的附加条件，比如说固定的路径长度或者加和的 target
这里好像只能从回文串的判定上来下功夫，通过将回文串的结果存储起来，然后直接访问数组来简化判定时间
但是这里我们发现，因为回溯是一定要走过每一个组合的，所以这里的回文串判定并没有起到太大的作用
但是我们可以不走我们已经走过的路，所以这里的回文串判定从最后一个字符开始不断向前
```c++
class Solution {
    vector<string> path;
    vector<vector<string>> ans;
    vector<vector<bool>> palindrome;

    // 注意这里我们传的是引用，这样时空复杂度都会低
    // 如果直接使用 string 就是每一次都复制一个string
    void dfs(const string& s, int start) {
        if (start >= s.size()) {
            ans.push_back(path);
            return;
        }

        for (int i = start; i < s.size(); i++) {
            if (palindrome[start][i]) {
                path.push_back(s.substr(start, i - start + 1));
                dfs(s, i + 1);
                path.pop_back();
            } else {
                continue;
            }
            
        }
    }

    void computePalindrome(const string& s) {
        palindrome.resize(s.size(), vector<bool>(s.size(), false));
        
        for (int start = s.size() - 1; start >= 0; start--) {
            for (int end = start; end < s.size(); end++) {
                if (start == end) {
                    palindrome[start][end] = true;
                } else if (end - start == 1) {
                    palindrome[start][end] = (s[start] == s[end]);
                } else {
                    palindrome[start][end] = 
                    (s[start] == s[end] && palindrome[start + 1][end - 1]);
                }
            }
        }
    }
public:
    vector<vector<string>> partition(string s) {
        computePalindrome(s);
        dfs(s, 0);
        return ans;
    }
};
```