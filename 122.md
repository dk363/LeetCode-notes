# 动态规划
## 递归
1. dp数组的含义 
dp(i, true) 代表第 i 天持有股票的最大利润
2. dp推导式
如果持有：dp[i, true] = max(dp[i - 1, true], dp[i - 1, false] - prices[i])
未持有：dp[i, false] = max(dp[i - 1, false], dp[i - 1, true] + prices[i])
3. 初始化
初始化为 -1 代表没有计算过
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<array<int, 2>> dp(n, {-1, -1});
        auto dfs = [&](this auto&& dfs, int i, bool hold) -> int {
            if (i < 0) {
                return hold ? INT_MIN : 0;
            }
            int& res = dp[i][hold];
            if (res != -1) {
                return res;
            }
            if (hold) {
                // 如果第 i 天持有股票 那么前一天肯定是 持有股票或是在今天买入
                return res = max(dfs(i - 1, true), dfs(i - 1, false) - prices[i]);
            }
            return res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]);
        };

        return dfs(n - 1, false);
    }
};
```
## 递推
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
      // dp[i][bool] 代表第 i 天 bool 持有股票时的利润
      // dp[i][true] = max(dp[i - 1][true], dp[i - 1][false] - prices[i])
      // dp[i][false] = max(dp[i - 1][false], fp[i - 1][true] + prices[i])
      
      int n = prices.size();
      vector<array<int, 2>> dp(n + 1, {0, 0});
      // dp[i][0] 代表持有未股票
      // dp[i][1] 代表持有股票
      dp[0][1] = INT_MIN;
      for (int i = 0; i < n; i++) {
        dp[i + 1][0] = max(dp[i][0], dp[i][1] + prices[i]);
        dp[i + 1][1] = max(dp[i][1], dp[i][0] - prices[i]);  
      }

      // 最后一天未持有股票肯定比持有股票钱多
      return dp[n][0];
    }
};
```