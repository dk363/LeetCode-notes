# 贪心 
## 左端点+ 动态范围
这里就是一个最大的重叠范围的问题
```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        ranges::sort(points, [](vector<int>& a, vector<int>& b) {
            return a[0] < b[0];
        });

        int ans = 1;
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > points[i - 1][1]) {
                ans++;
            } else {
                // 这里用原本的数组动态变化范围
                points[i][1] = min(points[i - 1][1], points[i][1]);
            }
        }
        return ans;
    }
};
```
## 右端点
如果用右端点实现，要贪心，每一次的端点都插在当前区间的最右边，如果当前区间不在端点之内，那么更新答案，更新端点
为什么这样可以呢？
因为如果要在一个区间内，当前的端点肯定是满足条件的最大的点，再往右就不能将当前的区间囊括在内
```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        ranges::sort(points, [](auto& a, auto& b) {
            return a[1] < b[1];
        });
        int arrPos = points[0][1], ans = 1;
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > arrPos) {
                ans++;
                arrPos = points[i][1];
            }
        }
        return ans;
    }
};
```