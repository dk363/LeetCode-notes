这一道题目的核心是将数据分为三个部分 其中值相同的要分在一起 
# 排序 + 分组统计
C(n, 3) 在选择到包含重复数据的组合时 * 重复数字的个数
那就不可以用 公式来计算了
先从暴力入手
枚举 时间复杂度是 n^3
这显然不可以
题目讲到不等三元组 就是说大小要不一样
而且可以看到 数字的顺序是不会影响答案的
那么先来排个序
在排序之后 将数组分成 3 部分
大于 等于 小于
这样将 三部分 相乘即可得到答案
```cpp
class Solution {
public:
    int unequalTriplets(vector<int>& nums) {
        ranges::sort(nums);
        int ans = 0;
        int n = nums.size();
        for (int i = 0; i < n - 1; i++) {
            int currI = i;
            while (i < n - 1 && nums[i + 1] == nums[i]) {
                i++;
            }
            // nums[i + 1] != nums[i]
            // 也就是说 i 处于相同数字串中的最后一位
            ans += (currI - 0) * (i - currI + 1) * (n - i - 1);
        }
        return ans;
    }
};
```

# hash
因为数据的先后顺序对答案没有影响 所以这里用哈希表也是没有问题的
将数据分为三个部分 已经遍历过的 正在遍历的 没有遍历过的
这里通过哈希统计出现的次数
```cpp
class Solution {
public:
    int unequalTriplets(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (int num : nums) {
            freq[num]++;
        }

        int n = nums.size();
        int ans = 0;
        int left = 0, right = n;

        for (auto& [val, cnt] : freq) {
            right -= cnt;
            ans += left * cnt * right;
            left += cnt;
        }
        return ans;
    }
};
```