# 回溯 + 剪枝 + 递归
这是一道很经典的回溯题目。回溯是什么，回溯是枚举所有的可能性的一种算法，因此回溯可以优化的地方就只有剪枝了
将回溯抽象为树结构，这样子就比较形象好理解
返回所有的数的组合
## 正序遍历
```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<int> path;
        vector<vector<int>> ans;

        auto dfs = [&](this auto&& dfs, int i) {
            if (path.size() == k) {
                ans.emplace_back(path);
                return;
            }

            for (int j = i; j <= n; j++) {
                path.emplace_back(j);
                dfs(j + 1);
                path.pop_back();
            }
        };
        dfs(1);
        return ans;
    }
};
```
## 倒序遍历
### 枚举
倒序遍历可以剪枝
在时空复杂度上更优
```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<int> path;
        vector<vector<int>> ans;

        auto dfs = [&](this auto&& dfs, int i) -> void {
            int d = k - path.size();
            if (d == 0) {
                ans.push_back(path);
                return;
            }

            // for 循环横向遍历，递归纵向遍历，回溯调整结果集
            for (int j = i; j >= d; j--) {
                path.push_back(j);
                dfs(j - 1);
                path.pop_back();
            }
        };

        dfs(n);
        return ans;
    }
};
```
### 选不选的角度
```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<int> path;
        vector<vector<int>> ans;

        auto dfs = [&](this auto&& dfs, int i) -> void {
            int d = k - path.size();
            if (d == 0) {
                ans.emplace_back(path);
                return;
            }

            if (i > d) { // i 是可以选择的最大的元素，间接代表元素的个数，如果 i > d 那么就有足够的元素可以选择
                dfs(i - 1);
            }

            path.emplace_back(i);
            dfs(i - 1);
            path.pop_back();
        };
        dfs(n);
        return ans;
    }
};
```