# 动态规划
```c++
class Solution {
    int rob1(vector<int>& nums, int start, int end) {
        int n = end - start + 1;
        if (n == 0) return 0;
        if (n == 1) return nums[start];
        vector<int> dp(n, 0);
        dp[0] = nums[start];
        dp[1] = max(nums[start], nums[start + 1]);
        for (int i = 2; i < n; i++) {
            dp[i] = max(dp[i - 2] + nums[start + i], dp[i - 1]);
        }
        return dp[n - 1];
    } 
public:
    int rob(vector<int>& nums) {
        // dp[i] 前 i 个房屋所能偷的最大金额和
        // dp[i % n] = max(dp[(i - 2) % n] + nums[i], dp[(i - 1) % n])
        // 环形要考虑的特殊情况是首尾不可以同时选择 因此将情况化简 
        // 分两种情况 一种是 选择第0个元素 一种是 不选第0个元素
        // 如果选择 0 个元素 就不可以选最后一个 如果 不选择0元素 就可以选最后一个
        // 然后max找出最大值
        int n = nums.size();
        if (n <= 1) {
            return nums[0];
        }
        return max(rob1(nums, 0, n - 2), rob1(nums, 1, n - 1));
    }
};
```