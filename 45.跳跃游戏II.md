# 贪心
和跳跃游戏不同，这里要找出最少步数
如何找出最少的步数，就是在可以达到的情况下，尽可能多走
如何多走呢？什么时候我们走下一步？
这里就用到了贪心，只有在当前的最大步数等于路程的时候，更新最大步数，同时维护一个已经走过的路径的可以到达的最大步数
```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int step = 0;
        int n = nums.size();
        if (n == 1) return 0;
        int curDis = 0, nextDis = 0;
        for (int i = 0; i < n; i++) {
            // i represents the location where we are, 
            // nums[i] represents steps we can walk when we stand on the grid
            nextDis = max(nums[i] + i, nextDis); 
            if (i == curDis) {
                curDis = nextDis;
                step++;
                if (curDis >= n - 1) break;
            }
        }
        return step;
    }
};
```