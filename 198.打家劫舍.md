# 递推
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 2);
        for (int i = 0; i < n; i++) {
            f[i + 2] = max(f[i] + nums[i], f[i + 1]);
        }
        return f[n + 1];
    }
};
```
# 回溯 + 记忆化搜索
两者的区别是一个是自底向上，一个是上向下
为什么回溯是自下向上呢？？？
这里的回溯是按照 选或者不选 的思路
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, -1);

        auto dfs = [&](this auto&& dfs, int i) -> int {
            if (i < 0) return 0;
            if (memo[i] != -1) {
                return memo[i];
            }

            return memo[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);
        };

        return dfs(n - 1);
    }
};
```
## 从前往后
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, -1);

        auto dfs = [&](this auto&& dfs, int i) -> int {
            if (i >= n) return 0;
            if (memo[i] != -1) {
                return memo[i];
            }

            return memo[i] = max(dfs(i + 1), dfs(i + 2) + nums[i]);
        };

        return dfs(0);
    }
};
```