# 回溯
```c++
class Solution {
    vector<int> path;
    vector<vector<int>> ans;

    void dfs(vector<int>& candidates, int target, int i, int sum) {
        if (sum > target) {
            return;
        }

        if (sum == target) {
            ans.push_back(path);
            return;
        }


        for (int j = i; j < candidates.size(); j++) {
            sum += candidates[j];
            path.push_back(candidates[j]);
            dfs(candidates, target, j, sum);
            sum -= candidates[j];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        dfs(candidates, target, 0, 0);
        return ans;
    }
};
```

# 回溯 + 排序
如果我们要进行剪枝的话，这里我们只能在 for 循环中做文章
我们可以想到的提前终止的条件有哪些？
1. 太大了
2. 超出 index 范围
如果太大了，怎么比？还是加上下一个比
那么这里就需要排序，不然的话会提前中止，导致失败

```c++
class Solution {
    vector<int> path;
    vector<vector<int>> ans;

    void dfs(vector<int>& candidates, int target, int i, int sum) {
        if (sum > target) {
            return;
        }

        if (sum == target) {
            ans.push_back(path);
            return;
        }

        // 这里
        for (int j = i; j < candidates.size() && sum + candidates[j] <= target; j++) {
            sum += candidates[j];
            path.push_back(candidates[j]);
            dfs(candidates, target, j, sum);
            sum -= candidates[j];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 这里
        dfs(candidates, target, 0, 0);
        return ans;
    }
};
```