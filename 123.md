# 动态规划

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp[i][bool][k] 代表前 i 个元素在是否持有股票的情况下第k次交易的最大利润
        // 0 代表未持有 1 代表持有
        // dp[i][0][k] = max(dp[i - 1][0][k], dp[i - 1][1][k] + prices[i])
        // dp[i][1][k] = max(dp[i - 1][1][k], dp[i - 1][0][k - 1] - prices[i])
        // dp[0][0][k] = 0
        // dp[0][-1][k] = -inf
        // dp[.][.][-1] = -inf
        // 其他都是 0
        if (prices.empty()) return 0;
        const int k = 2; 
        int n = prices.size();
        vector<array<int, 2>> dp(k + 2, {INT_MIN, INT_MIN});
        for (int j = 1; j < k + 2; j++) {
            dp[j][0] = 0;
        }

        for (int p : prices) {
            for (int j = k + 1; j > 0; j--) {
                // 从前向后遍历
                // 这里将卖出股票作为标志
                dp[j][0] = max(dp[j][0], dp[j - 1][1] + p);
                dp[j][1] = max(dp[j][1], dp[j][0] - p);
            }
        }
        return dp[k + 1][0];
    }
};
```