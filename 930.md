# 前缀和
对于数组和题目 可以有这个式子算出 子数组的和
j > i
sum[j] - sum[i] == goal
sum[i] = sum[j] - goal
为什么是 sum[i] 而不是
sum[j] = sum[i] + goal
为了记录答案
将之前的 sum 加入 map 中
所以 sum[i] 会先被加入 map 中 供我们使用
```cpp
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        vector<int> pre_num(nums.size() + 1);
        for (int i = 1; i < pre_num.size(); ++i) {
            pre_num[i] = pre_num[i - 1] + nums[i - 1];
        }

        unordered_map<int, int> map;
        int ans = 0;
        for (int& num : pre_num) {
            ans += map[num - goal];
            ++map[num];
        }
        return ans;
    }
};
```
# 固定长度的滑窗
对于求和问题 且题目说明了是连续长度
那么应该可以想到滑动窗口
滑动窗口就是用来解决 固定的 小于等于的 goal 的问题
这里维护两个窗口
一个窗口维护 小于等于的
一个窗口维护 小于的
两个窗口的下标之差 就是等于 goal 的
## 那么这里为什么要用两个窗口呢
nums 中可能会出现 0 
在一个窗口中 在while循环中 可能会漏掉这一种可能性
```cpp
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        int sum1 = 0, sum2 = 0;
        int left1 = 0, left2 = 0;
        int ans = 0;

        for (int right = 0; right < nums.size(); ++right) {
            sum1 += nums[right];
            while (left1 <= right && sum1 > goal) {
                sum1 -= nums[left1];
                ++left1;
            }

            sum2 += nums[right];
            while (left2 <= right && sum2 >= goal) {
                sum2 -= nums[left2];
                ++left2;
            }
            ans += (left2 - left1);
        }
        return ans;
    }
};
```
## 另一种版本的滑窗
```cpp
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        return atMost(nums, goal) - atMost(nums, goal - 1);
    }

    private int atMost(int[] nums, int goal) {
        if (goal < 0) return 0;
        int left = 0, sum = 0, cnt = 0;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];

            while (sum > goal) {
                sum -= nums[left];
                left++;
            }

            cnt += right - left + 1;
        }

        return cnt;
    }
}
```