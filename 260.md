# 位运算
a xor a == 0
所以这里用 异或和 可以消除重复元素的影响
因为只出现过一次 所以剩下的两个数之间肯定至少有一位 是不同的
如何找出这不同的一位呢？
可以观察到这不同的一位肯定要从右向左找
## 如何得到最低位 1
```text
       s = 101100
      ~s = 010011
(~s - 1) = 010100 == -s
  -s & s = 000100
```
在得到最低位 1 之后 通过 1 来区分
那么如何区分呢？
因为这个 lowbit 除了这个 1 其余位都是 0 
所以通过 & 来找 这一位同样是 0 的另一个数字
同样的 再一次遍历数组 通过这个 1 可以将数组分为两部分进行 异或和
同样的相同的数字对于结果是没有影响的
因此异或和的结果就是要找的两个数字
```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        unsigned int xorAll = 0;
        for (int& num : nums) {
            xorAll ^= num;
        }
        int lowBit = ((-xorAll) & xorAll); // 取负数主义越界问题
        vector<int> ans(2, 0);
        for (int& num : nums) {
            if ((num & lowBit) == 0) {
                ans[0] ^= num;
            } else {
                ans[1] ^= num;
            }
        }
        return ans;
    }
};
```