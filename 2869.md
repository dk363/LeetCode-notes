# 位运算
向左 k 位 代表乘以 2^k
用 k 位有 1 代表有这个数
遍历数字 然后将数字看作是长为 k 的首位为 1 的一串二进制数字
然后和 mark 进行或运算 
如果和 11111...0 这样长为 k 位的判定标准一起的 和运算为该数字本身
那么说明我们已经将 1 ~ k 的数字找齐了
## 为什么会想到位运算
在二进制中 有代表 1 无代表 0 
那么计算数字是否出现过的时候 出现这里就可以抽象出两种状态
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int k) {
        int n = nums.size();
        long long u = (2LL << k) - 2; // 1~k 2^1
        long long s = 0;
        for (int i = n - 1; ; --i) {
            s |= (1LL << nums[i]);
            if ((s & u) == u) {
                return n - i;
            }
        }
        return n;
    }
};
```