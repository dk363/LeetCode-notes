# 动态规划
```c++
class Solution {
public:
    double frogPosition(int n, vector<vector<int>> &edges, int t, int target) {
        vector<vector<int>> g(n + 1);
        g[1] = {0}; // 减少额外判断的小技巧 虚拟头节点
        for (auto &e: edges) {
            int x = e[0], y = e[1];
            g[x].push_back(y);
            // 树的结构是输入的 edges 数组动态定义的，例如 edges = [[1,2], [2,3]] 表示 1-2-3 的链，但 edges = [[2,1], [3,2]] 本质上是同一棵树。所以这里需要双向建树
            g[y].push_back(x); // 建树
        }
        double ans = 0.0; // 如果将ans初始化为 1 那么在没有找到target 的情况下也会返回 1 这并不是我们想要的

        function<bool(int, int, int, long long)> dfs = [&](int x, int fa, int left_t, long long prod) -> bool {
            // t 秒后必须在 target（恰好到达，或者 target 是叶子停在原地）
            if (x == target && (left_t == 0 || g[x].size() == 1)) {
                ans = 1.0 / prod;
                return true;
            }
            if (x == target || left_t == 0) return false;
            for (int y: g[x])  // 遍历 x 的儿子 y
                if (y != fa && dfs(y, x, left_t - 1, prod * (g[x].size() - 1))) // -1 是为了去掉父节点的方向 题目这里说是无向图，但还是有方向的 从节点开始 自顶向下
                    return true; // 找到 target 就不再递归了
            return false; // 未找到 target
        };

        dfs(1, 0, t, 1);
        return ans;
    }
};
```