# 单调栈
## 从右到左
将当前元素看作是一座座山峰的高度
从右向左看 
1 1 2 3 5 2 3 7
7 是当前最大的
然后是 3 
然后是 2
然后是 5 此时 2 3 小于 5 那么如何更新 5 这个元素的答案呢？
将小于 5 的元素踢出去 
原来的队列 2 3 7
变化之后 5 7
那么这个时候就可以访问 7 的下标 然后用 下标 - 当前的i 即可得出答案
如果当前元素大于栈顶的元素 将栈顶的元素弹出 
那么此时栈顶元素有两个
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        int n = temperatures.size();
        vector<int> ans(n, 0);
        for (int i = n - 1; i >= 0; i--) {        
          while (!st.empty() && temperatures[i] >= temperatures[st.top()]) {
            st.pop();
          }
          if (!st.empty()) {
            ans[i] = st.top() - i;
          }
          st.push(i);
        }
        return ans;
    }
};
```
# 从左到右
从左向右看 如果下一个元素比当前元素大，那么得到答案
但是这样我们就需要遍历 时间复杂度最坏情况下是平方
我们需要一个数据结构将没有答案的数保存起来 暂时
如果这些当前的数字大于我们保存的 数字那么更新答案
```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        int n = temperatures.size();
        vector<int> ans(n, 0);
        for (int i = 0; i < n; i++) {
          while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
            ans[st.top()] = i - st.top();
            st.pop();
          }
          st.push(i);
        }

        return ans;
    }
};
```