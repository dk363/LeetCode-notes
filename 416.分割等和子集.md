# 二维数组 + 选或不选
仿照 494 的做法
通过将数组中的元素加入背包中，查看是否可以到 数组总和的一半的方法返回 true 或者是 false
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = reduce(nums.begin(), nums.end());
        if (sum < 0 || sum % 2) {
            return false;
        }
        sum /= 2;

        int n = nums.size(); // 可选的元素数目
        
        vector f(n + 1, vector<int>(sum + 1, -1));
        f[0][0] = true;

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            for (int j = 0; j <= sum; j++) {
                if (j >= x) { // 如果 j < x 那我们只能不选
                    f[i + 1][j] = f[i][j] || f[i][j - x];
                } else {
                    f[i + 1][j] = f[i][j];
                }
            }
        }
        return f[n][sum];
    }
};
```
# 一维数组
因为之前的数组 i c 代表前 i 个物品 在重量和不超过 c 的情况下的最大的价值
这里物品的重量和价值是相同的值，那么就没有必要用二维数组了
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = reduce(nums.begin(), nums.end());

        if (sum % 2) {
            return false;
        }

        int target = sum / 2;
        vector<int> f(target + 1, 0);

        for (int x : nums) {
            for (int j = target; j >= x; j--) {
                // f[j] = max(f[j], f[j - weight] + value) 这里 weight 和 value 相等
                f[j] = max(f[j], f[j - x] + x);
            }
        }

        return f[target] == target;
    }
};
```