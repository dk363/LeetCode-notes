# 正反两次扫描
这里有一点像贪心
在第一个巫师 加工完第一瓶药水之后 立马让第二个巫师加工第一瓶药水 这个时候先让中间有空闲时间 也就是用 max 函数找到下一次可以进行下一次酿造的时间
然后再倒推第二个巫师最早可以在哪里进行加工 然后重复上述过程 遍历所有的巫师 通过数组更新
```cpp
class Solution {
public:
    long long minTime(vector<int>& skill, vector<int>& mana) {
        int n = skill.size();
        vector<long long> last_finish(n);
        for (int& m : mana) {
            long long curr_sum = 0;
            for (int i = 0; i < n; ++i) {
                curr_sum = max(curr_sum, last_finish[i]) + m * skill[i];
            }

            last_finish[n - 1] = curr_sum;

            for (int i = n - 2; i >= 0; --i) {
                last_finish[i] = last_finish[i + 1] - m * skill[i + 1];
            }
        }
        return last_finish[n - 1];
    }
};
```