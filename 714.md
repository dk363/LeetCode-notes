# 动态规划
## 递归
dp 代表今天结束的利润

dp(i, true) = max(dfs(i - 1, true), dfs(i - 1, false) - prices[i])
dp(i, false) = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i] - fee)

dp(-1, true) = -1
dp(-1, false) = 0

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<array<int, 2>> dp(n + 1, {-1, -1});
        
        auto dfs = [&](this auto&& dfs, int i, bool hold) -> int {
            if (i < 0) {
                if (hold) {
                    return INT_MIN / 2;
                } else {
                    return 0;
                }
            }
            int& res = dp[i][hold];
            if (res != -1) {
                return res;
            }
            if (hold) {
                return res = max(dfs(i - 1, true), dfs(i - 1, false) - prices[i]);
            }
            return res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i] - fee);
        };

        return dfs(n - 1, false);
    }
};
```
## 递推
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<array<int, 2>> dp(n + 1);
        dp[0][1] = INT_MIN / 2;
        for (int i = 0; i < n; i++) {
            dp[i + 1][0] = max(dp[i][0], dp[i][1] + prices[i] - fee);
            dp[i + 1][1] = max(dp[i][1], dp[i][0] - prices[i]);
        }

        return dp[n][0];
    }
};
```