# 最小堆
```cpp
class Solution {
    const vector<pair<int, int>> DIRS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        // 就是说从最短的木板开始
        // 然后慢慢向外扩张
        // 在扩张的同时计算此时是否可以形成一个木桶，此时的木桶可以装多少水
        int m = heightMap.size(), n = heightMap[0].size();

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                // 将最外侧的加入pq
                if (i == m - 1 || j == n - 1 || i == 0 || j == 0) {
                    pq.emplace(heightMap[i][j], i, j);
                    heightMap[i][j] = -1; // 标记已经访问过了
                }
            }
        }

        int ans = 0;
        while (!pq.empty()) {
            // 取出最短的板
            auto [height, i, j] = pq.top();
            pq.pop();

            for (auto& [dx, dy] : DIRS) {
                int x = i + dx, y = j + dy;
                if (x >= 0 && x < m && y >= 0 && y < n && heightMap[x][y] >= 0) {
                    // 如果里面的板小于外面的板，那么就说明这里可以装水
                    // 因为这里已经保证了 height 是最小的，那么不需要担心会漏水的问题
                    if (height > heightMap[x][y]) {
                        ans += height - heightMap[x][y];
                    }
                    // 替换为较长的板
                    pq.emplace(max(height, heightMap[x][y]), x, y);
                    heightMap[x][y] = -1;
                }
            }
        }
        return ans;
    }
};
```