# 回溯
我们可以注意到，全排列可以每一次的 start 都是 0，全排列与之前的组合不同
组合的答案长度是可变的，相当于是定长的组合 + 可重复问题
组合问题中，如果选取这一个元素，那么在后面的遍历中我们肯定已经将所有的组合都考虑到了，这里我们可以选取重复的元素，也就是同样元素不同组合也是需要计入答案的
这里两种写法
一种是 push_back 动态增长 和 拷贝
一种是 预分配空间
这里第二种写法更好理解，但是第一种写法时空复杂度更好
回溯中的 for 循环的本质是 n 叉树分支的过程，增加判定条件也就是剪枝的过程 
## 解法一
```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> ans;
        vector<int> path(n);
        vector<bool> seen(nums.size(), false);
        auto dfs = [&](this auto&&dfs, int i) {
            if (i == n) {
                ans.emplace_back(path);
                return;
            }

            for (int j = 0; j < n; j++) {
                if (!seen[j]) {
                    seen[j] = true;
                    // 这里是预分配
                    path[i] = nums[j];
                    dfs(i + 1);
                    seen[j] = false;
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```

## 解法二
```c++
class Solution {
    vector<int> path;
    vector<vector<int>> ans;
    void dfs(vector<int> nums, vector<bool> seen) {
        if (path.size() == nums.size()) {
            ans.push_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (seen[i]) continue;
            seen[i] = true;
            path.push_back(nums[i]); // 这里是动态分配
            dfs(nums, seen);
            path.pop_back();
            seen[i] = false;
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> seen(nums.size(), false);
        dfs(nums, seen);
        return ans;
    }
};
```