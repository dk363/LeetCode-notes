# 回溯
题目要求要去除重复的排列
像之前的 40.组合总和II 一样
去重的做法是将元素排序，然后通过额外的判定来达到目的
为什么排序可以去重呢？
重复元素，如何判定？因为排序可以将重复的元素放在一起
在排序之后，无序的数组会变得有序起来，重复的元素会放在一起，这样我们可以间接把握元素之间的顺序，通过前后大小一致的元素，我们可以有判定的
而且在回溯的题目中，排序的支出可以几乎忽略不计
```c++
class Solution {

public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        ranges::sort(nums);
        int n = nums.size();
        vector<int> path(n);
        vector<bool> seen(n, false);
        vector<vector<int>> ans;
        auto dfs = [&](this auto&&dfs, int start) {
            if (start == n) {
                ans.emplace_back(path);
                return;
            }

            for (int i = 0; i < n; i++) {
                // 第一种情况是已经填过了，那不必多说，肯定不能入队
                // 第二种情况是没有填过，如果这个元素没有填过 而且这个元素和前一个元素相同，那么我们 continue
                // 为什么 continue
                // 因为在之前的遍历过程中，这个重复元素打头的情况我们已入队了
                // 也就是相同的前缀的过程中，有一点像字典树这里
                if (seen[i] || (i > 0 && nums[i] == nums[i - 1] && !seen[i - 1])) {
                    continue;
                }
                seen[i] = true;
                path[start] = nums[i];
                dfs(start + 1);
                seen[i] = false;
            }
        };

        dfs(0);
        return ans;
    }
};
```