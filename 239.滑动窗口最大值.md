# 单调递减队列
维护一个单调递减的序列
检查当前的元素，如果当前元素要比队尾元素大，我们就将队尾元素弹出
将当前元素插入，因为有上一步，所以当前元素要么前面没人，要么前面的人都比自己大，形成了单调栈
这样就找到了当前窗口之中最大的元素
检查当前的队首元素是否已经在窗口之外
然后检查目前的 i 是否已经有 k 那么长，如果有就更新答案
为什么要这样想呢？
将问题简化一下，题目要找的是窗口中的最大值，那么只要关注窗口中有可能成为最大值的元素即可
要保存最大元素，有几种办法？
    前缀 后缀 数组
    堆
    优先队列
    直接排序
    暴力比较
    分块RMQ（将数组分成多个小块，预处理每个块的最大值，有点像目录
> RECALL：双端队列可以从两端添加和移除元素
> 
前缀后缀数组不能查询窗口内的元素，如果第一个元素很大，后面的值就全是第一个元素了
这里可以用堆，用 堆 + 哈希表 保存元素的值和下标，然后在移除最左边的元素，但是堆移除元素需要遍历堆内的每一个元素，才可以找到下标小于 left 的（也就是需要移出窗口的元素）
这里的实现是 O(NlogK) (k 为窗口大小)
暴力排序肯定就不需要考虑了，都是刷算法题了还用暴力
优先队列呢？队列是双端的，可以控制控制长度和元素的增加减少，欸，感觉有戏。
那么如何控制这个队列呢？像上面说的，只需要关注窗口中有可能成为最大值的元素即可，
对于新来的元素，将他与之前的元素比较，如果比他大，那么完事大吉，直接更新答案。
如果比他小，这个元素还要不要？
如果不要 比如说 5 2 3 -1 如果不要 3，那么窗口移到最后的时候不就只能用 -1 当最大值（前两个值已经被丢掉了，没有加入队列中）
如果要，怎么要呢？注意到，这里我们只让队列中有一个元素，没有发挥队列的作用，（上面的操作使用一个变量实际也可以轻易完成）
如何发挥队列的作用呢？
多加几个元素进去，怎么加元素，加什么元素？
队列已经为我们提供了 push_front() push_back() 方法，要加的是有可能成为最大值的元素。什么叫有可能成为最大值，将新元素和老元素比较，如果小，就加入队尾之中，答案每一次从队首更新，记录nums的下标
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        deque<int> q;

        for (int i = 0; i < nums.size(); i++) {
            while (!q.empty() && nums[q.back()] < nums[i]) {
                q.pop_back();
            }

            q.push_back(i);

            int left = i - k + 1;
            if (q.front() < left) {
                q.pop_front();
            }

            if (left >= 0) {
                ans[left] = nums[q.front()];
            }
        }
        return ans;
    }
};
```