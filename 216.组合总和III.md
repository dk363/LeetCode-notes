# 回溯
## 正序
```c++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> path;
        vector<vector<int>> ans;

        auto dfs = [&](this auto&& dfs, int i, int sum) {
            if (path.size() > k || sum > n) return;
            if (path.size() == k && sum == n) {
                ans.emplace_back(path);
                return;
            }

            for (int j = i; j <= 9; j++) {
                path.emplace_back(j);
                dfs(j + 1, sum + j);
                path.pop_back();
            }
        };
        dfs(1, 0);
        return ans;
    }
};
```
## 倒序
```c++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> path;
        vector<vector<int>> ans;

        auto dfs = [&](this auto&& dfs, int i, int left_sum) -> void {
            int d = k - path.size();
            // 当前的和 大于 target 或者是 后面最大的数加起来都没有 target 大 剪枝
            if (left_sum < 0 || left_sum > (i + i - d + 1) * d / 2) {
                return;
            }

            // 元素数目达到上限，返回
            if (d == 0) {
                ans.push_back(path);
                return;
            }

            for (int j = i; j >= d; j--) {
                path.push_back(j);
                dfs(j - 1, left_sum - j);
                path.pop_back();
            }
        };

        dfs(9, n);
        return ans;
    }
};
```